"use strict";(self.webpackChunkmonogame_extended_website=self.webpackChunkmonogame_extended_website||[]).push([[4113],{9888:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>r});var o=t(4848),i=t(8453);const l={id:"object-pooling",title:"Object Pooling",sidebar_label:"Object Pooling"},s=void 0,a={id:"features/object-pooling/object-pooling",title:"Object Pooling",description:"This page is up to date for MonoGame.Extended @mgeversion@.  If you find outdated information, please open an issue.",source:"@site/docs/features/object-pooling/object-pooling.md",sourceDirName:"features/object-pooling",slug:"/features/object-pooling/",permalink:"/docs/features/object-pooling/",draft:!1,unlisted:!1,editUrl:"https://github.com/craftworkgames/craftworkgames.github.io/tree/develop/docs/features/object-pooling/object-pooling.md",tags:[],version:"current",frontMatter:{id:"object-pooling",title:"Object Pooling",sidebar_label:"Object Pooling"},sidebar:"docs",previous:{title:"Collections",permalink:"/docs/features/collections/"},next:{title:"Gum Forms",permalink:"/docs/features/ui/gum/gum-forms/"}},c={},r=[{value:"Pool",id:"pool",level:2},{value:"Create example Enemy class for Pool",id:"create-example-enemy-class-for-pool",level:3},{value:"Creating the Pool",id:"creating-the-pool",level:3},{value:"Managing the list of alive Objects",id:"managing-the-list-of-alive-objects",level:3},{value:"Obtaining an Object from the Pool",id:"obtaining-an-object-from-the-pool",level:3},{value:"Managing the Alive Objects",id:"managing-the-alive-objects",level:3},{value:"Send an object back to the pool",id:"send-an-object-back-to-the-pool",level:3},{value:"Removing the object from the alive list",id:"removing-the-object-from-the-alive-list",level:3},{value:"ObjectPool",id:"objectpool",level:2},{value:"ObjectPool Features",id:"objectpool-features",level:3},{value:"Creating a Pool-able Object with the <code>IPoolable</code> interface",id:"creating-a-pool-able-object-with-the-ipoolable-interface",level:3},{value:"Creating an <code>ObjectPool</code>",id:"creating-an-objectpool",level:3},{value:"Getting a Pooled Object",id:"getting-a-pooled-object",level:3},{value:"Returning an Object to the Pool",id:"returning-an-object-to-the-pool",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.admonition,{title:"Up to date",type:"tip",children:(0,o.jsxs)(n.p,{children:["This page is ",(0,o.jsx)(n.strong,{children:"up to date"})," for MonoGame.Extended ",(0,o.jsx)(n.code,{children:"4.0.3"}),".  If you find outdated information, ",(0,o.jsx)(n.a,{href:"https://github.com/craftworkgames/craftworkgames.github.io/issues",children:"please open an issue"}),"."]})}),"\n",(0,o.jsxs)(n.p,{children:["Object pooling is an optimization pattern. It's used to improve performance, in certain cases, by re-using objects instead of allocating memory for them on demand. In C/C++, one the things object pooling has to offer is a solution to avoid ",(0,o.jsx)(n.a,{href:"http://stackoverflow.com/questions/3770457/what-is-memory-fragmentation",children:"memory fragmentation"}),". In C#, we don't have to worry about memory fragmentation thanks to ",(0,o.jsx)(n.a,{href:"https://msdn.microsoft.com/en-us/library/ee787088",children:"garbage collection"}),". However, garbage collection can be still be too expensive for certain parts of real-time applications, especially on mobile devices with slower CPUs and simpler garbage collectors. ",(0,o.jsx)(n.a,{href:"http://gameprogrammingpatterns.com/object-pool.html",children:"More details on object pooling here"}),"."]}),"\n",(0,o.jsx)(n.admonition,{title:"Abstract Analogy",type:"note",children:(0,o.jsxs)(n.p,{children:["You can think about an object pool like desks in a classroom.  There are a designated number of desks in each room for students to use.  When a student takes over a desk for the class period, their information is assigned to that spot, and they place their items in the desk.  When the student leaves for their next class, the desk still remains (",(0,o.jsx)(n.em,{children:"The pool still has the object"}),").  When a student arrives for the next class, the old desk isn't tossed in the trash (",(0,o.jsx)(n.em,{children:"Garbage collected"}),"), nor is a new desk created (",(0,o.jsx)(n.em,{children:"Class instantiation"}),"), and then installed in the class (",(0,o.jsx)(n.em,{children:"stored in a list"}),").  Instead the new student simply uses one of the open desks (",(0,o.jsx)(n.em,{children:"object reuse/pooling"}),").  This saves on time, just like with Object Pooling."]})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Monogame.Extended"})," has 2 different Object Pooling options you can utilize."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Pool<T>"})," where T is any class"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"ObjectPool<T>"})," where T is a class that implements the ",(0,o.jsx)(n.code,{children:"IPoolable"})," interface"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The main difference between these two is that ",(0,o.jsx)(n.code,{children:"Pool<T>"}),' does not track the "alive" objects.  It is simply a facility to manage a list of your objects, that are available to use from the pool, that are "dead".']}),"\n",(0,o.jsx)(n.admonition,{type:"caution",children:(0,o.jsxs)(n.p,{children:["Always profile the game for performance problems!\nUsing a ",(0,o.jsx)(n.code,{children:"Pool<T>"}),"/",(0,o.jsx)(n.code,{children:"ObjectPool<T>"})," without first profiling for the need of one may result in a ",(0,o.jsx)(n.em,{children:"decrease"})," in performance in certain cases. If you are unsure, don't use the object pooling pattern."]})}),"\n",(0,o.jsx)(n.h2,{id:"pool",children:"Pool"}),"\n",(0,o.jsxs)(n.p,{children:["This is a simplified Pooling system that uses a ",(0,o.jsx)(n.a,{href:"/docs/features/collections/#deque",children:(0,o.jsx)(n.code,{children:"Deque"})})," for the dead objects.  Since this collection doesn't contain a way to track the alive objects, you'll need to do that yourself.  This example uses a List to keep track of the alive objects."]}),"\n",(0,o.jsx)(n.h3,{id:"create-example-enemy-class-for-pool",children:"Create example Enemy class for Pool"}),"\n",(0,o.jsx)(n.p,{children:"This class is just an example for demonstration purposes."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class Enemy \n{\n    public int Health {get; set;}\n    public float Position {get; set;}\n\n    public Enemy(){ }\n\n    public void Reset()\n    {\n        Health = 0;\n        Position = 0;\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"creating-the-pool",children:"Creating the Pool"}),"\n",(0,o.jsxs)(n.p,{children:["Here we create an instance of ",(0,o.jsx)(n.code,{children:"Pool<T>"})," where ",(0,o.jsx)(n.code,{children:"T"})," is ",(0,o.jsx)(n.code,{children:"Enemy"}),".  We pass in the function that is used to create new instances of Enemy, the reset function for when an enemy is placed back in the pool with the ",(0,o.jsx)(n.code,{children:"Free"})," method, and the maximum capacity."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"Pool<Enemy> enemyPool = new Pool<Enemy>(\n    createItem: () => new Enemy(),      // Function that will be executed when we need to create a new Enemy\n    resetItem: enemy => enemy.Reset(),  // Method that will be executed when the Enemy is returned to the pool for re-use\n    capacity: 10                        // Maximum pool capacity, can not grow\n);\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsx)(n.p,{children:"Having too large of a capacity will waste memory, but having too small of a capacity will limit the number of object instances that can be pooled."})}),"\n",(0,o.jsx)(n.h3,{id:"managing-the-list-of-alive-objects",children:"Managing the list of alive Objects"}),"\n",(0,o.jsx)(n.p,{children:"Create a list to hold our Enemy (This could be anything you wish, even a Bag or Deque)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"List<Enemy> enemies = new List<Enemy>();\n"})}),"\n",(0,o.jsx)(n.h3,{id:"obtaining-an-object-from-the-pool",children:"Obtaining an Object from the Pool"}),"\n",(0,o.jsx)(n.p,{children:"The Obtain method here will return an already created (but reset) instance of Enemy if one exists in the pool, otherwise it will create a New Enemy and send it back."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"Enemy enemy = enemyPool.Obtain();\n"})}),"\n",(0,o.jsx)(n.h3,{id:"managing-the-alive-objects",children:"Managing the Alive Objects"}),"\n",(0,o.jsx)(n.p,{children:'Add the Enemy instance to our "alive" list'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"enemies.Add(enemy);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"send-an-object-back-to-the-pool",children:"Send an object back to the pool"}),"\n",(0,o.jsx)(n.p,{children:"When we no longer need the object, we can send it back to the pool for reuse."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"enemyPool.Free(enemy);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"removing-the-object-from-the-alive-list",children:"Removing the object from the alive list"}),"\n",(0,o.jsx)(n.p,{children:"Finally we need to remove the enemy from our alive list"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"enemies.Remove(enemy);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"objectpool",children:"ObjectPool"}),"\n",(0,o.jsxs)(n.p,{children:["Managing the alive list with the ",(0,o.jsx)(n.code,{children:"Pool<T>"})," can add a bit more work to your code, so if you don't want to manage that yourself, you can try the ",(0,o.jsx)(n.code,{children:"ObjectPool<T>"})," below."]}),"\n",(0,o.jsx)(n.h3,{id:"objectpool-features",children:"ObjectPool Features"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The Object you want to use in the ",(0,o.jsx)(n.code,{children:"ObjectPool<T>"})," must implement the ",(0,o.jsx)(n.code,{children:"IPoolable"})," interface."]}),"\n",(0,o.jsxs)(n.li,{children:["The list of alive objects is stored in a ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Doubly_linked_list",children:"Doubly Linked List"})]}),"\n",(0,o.jsxs)(n.li,{children:["The list of dead objects is stored in a ",(0,o.jsx)(n.a,{href:"/docs/features/collections/#deque",children:"Deque"})]}),"\n",(0,o.jsxs)(n.li,{children:["The behavior when requesting an object from the pool when it is full has 3 behaviors or Policies:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["ObjectPoolIsFullPolicy.",(0,o.jsx)(n.em,{children:"ReturnNull"})," - Returns the Null value"]}),"\n",(0,o.jsxs)(n.li,{children:["ObjectPoolIsFullPolicy.",(0,o.jsx)(n.em,{children:"IncreaseSize"})," - Adds 1 more spot, creates a new instance of the Type"]}),"\n",(0,o.jsxs)(n.li,{children:["ObjectPoolIsFullPolicy.",(0,o.jsx)(n.em,{children:"KillExisting"})," - Resets the last object in the pool, and reuses it."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.h3,{id:"creating-a-pool-able-object-with-the-ipoolable-interface",children:["Creating a Pool-able Object with the ",(0,o.jsx)(n.code,{children:"IPoolable"})," interface"]}),"\n",(0,o.jsx)(n.p,{children:"The following is a code snippet with comments demonstrating how to implement the interface.  We'll use the same Enemy example here."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"class EnemyPoolable : IPoolable\n{\n    // Example attributes\n    public int Health {get; set;}\n    public float Position {get; set;}\n\n    // ... Your other Enemy class code here\n\n    // IPoolable interface methods/attributes implemented below\n    private Action<IPoolable> _returnAction;\n\n    void IPoolable.Initialize(Action<IPoolable> returnAction)\n    {\n        // copy the instance reference of the return function so we can call it later\n        _returnAction = returnAction;\n    }\n\n    public void Return()\n    {\n        // Reset your classes attributes here\n        Health = 0;\n        Position = 0;\n\n        // check if this instance has already been returned\n        if (_returnAction != null)\n        {\n            // not yet returned, return it now\n            _returnAction.Invoke(this);\n            // set the delegate instance reference to null, so we don't accidentally return it again\n            _returnAction = null;\n        }\n    }\n\n    public IPoolable NextNode { get; set; }\n    public IPoolable PreviousNode { get; set; }\n}\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"creating-an-objectpool",children:["Creating an ",(0,o.jsx)(n.code,{children:"ObjectPool"})]}),"\n",(0,o.jsxs)(n.p,{children:["Instantiating an ",(0,o.jsx)(n.code,{children:"ObjectPool<T>"})," is similar to any generic collection, i.e ",(0,o.jsx)(n.code,{children:"List<T>"}),", but ",(0,o.jsx)(n.code,{children:"T"})," has to implement ",(0,o.jsx)(n.code,{children:"IPoolable"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"int startingCapacity = 10; // the default is 16\nvar objectPool = new ObjectPool<EnemyPoolable>(\n    instantiationFunc: () => new EnemyPoolable(), \n    capacity: startingCapacity\n);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The required ",(0,o.jsx)(n.code,{children:"instantiationFunc"})," parameter is the delegate responsible for creating each object instance if there are no available instances."]}),"\n",(0,o.jsx)(n.h3,{id:"getting-a-pooled-object",children:"Getting a Pooled Object"}),"\n",(0,o.jsx)(n.p,{children:"A free pooled object instance can be requested from the objectPool instance."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"var myPoolable = objectPool.New();\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:["If the objectPool is full, and you're using the default isFullPolicy of ObjectPoolIsFullPolicy.ReturnNull, myPoolable will return a ",(0,o.jsx)(n.code,{children:"null"})]})}),"\n",(0,o.jsx)(n.h3,{id:"returning-an-object-to-the-pool",children:"Returning an Object to the Pool"}),"\n",(0,o.jsx)(n.p,{children:"When the object instance is no longer needed it should be returned to the pool so it can be re-used."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cs",children:"myPoolable.Return();\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var o=t(6540);const i={},l=o.createContext(i);function s(e){const n=o.useContext(l);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(l.Provider,{value:n},e.children)}}}]);